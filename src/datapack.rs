use std::path::Path;

pub struct Datapack {
    pub description: String,
}

impl Datapack {
    /*
    pub fn run_index(&self) -> Option<usize> {
        self.functions
            .iter()
            .enumerate()
            .find(|(_, f)| f.id == FunctionId::new("run"))
            .map(|(i, _)| i)
    }
    */

    pub fn new() -> Self {
        Self {
            description: "Autogenerated by wasmcraft".to_string(),
        }
    }

    /// Creates a datapack with the given root directory, erasing the previous contents of the folder.
    pub fn save(&self, output_folder: &Path) -> Result<(), std::io::Error> {
        if output_folder.exists() {
            eprintln!("Removing previous contents of output directory");
            std::fs::remove_dir_all(output_folder)?;
        }

        std::fs::create_dir(&output_folder)?;

        let mcmeta_contents = serde_json::json!({
            "pack": {
                "pack_format": 5,
                "description": self.description
            }
        });

        std::fs::write(
            output_folder.join("pack.mcmeta"),
            mcmeta_contents.to_string(),
        )?;

        /*
        std::fs::create_dir_all(output_folder.join(Path::new("data/setup/functions/")))?;
        std::fs::write(
            output_folder.join(Path::new("data/setup/functions/setup.mcfunction")),
            SETUP_STR,
        )?;

        std::fs::create_dir_all(output_folder.join(Path::new("data/stdout/functions/")))?;
        std::fs::write(
            output_folder.join(Path::new("data/stdout/functions/putc.mcfunction")),
            PUTC_STR,
        )?;
        std::fs::write(
            output_folder.join(Path::new("data/stdout/functions/flush.mcfunction")),
            FLUSH_STR,
        )?;
        */

        /*
        for func in self.functions.iter() {
            let contents = func
                .cmds
                .iter()
                .map(|cmd| cmd.to_string())
                .collect::<Vec<_>>();

            let contents = contents.join("\n");

            let path = func.id.path();
            let path_folders = &path[..path.len() - 1];
            let file_name = &path[path.len() - 1];

            let mut full_path = output_folder
                .join(Path::new("data"))
                .join(Path::new(func.id.namespace()))
                .join(Path::new("functions"));

            for folder in path_folders {
                full_path = full_path.join(Path::new(folder));
            }

            std::fs::create_dir_all(&full_path)?;

            full_path = full_path.join(format!("{}.mcfunction", file_name));

            std::fs::write(full_path, contents.as_bytes())?
        }
        */

        Ok(())
    }

    pub fn write_function(&self, output_folder: &Path, namespace: &str, mut name: &str, contents: &str) -> std::io::Result<()> {
        let prefix = if let Some((a, b)) = name.split_once('/') {
            name = b;
            a
        } else {
            ""
        };

        let func_folder = output_folder.join(format!("data/{}/functions/{}", namespace, prefix));
        std::fs::create_dir_all(&func_folder)?;

        let func_name = format!("{}.mcfunction", name);

        std::fs::write(func_folder.join(Path::new(&func_name)), contents)?;

        Ok(())
    }
}